/*
내 풀이보다 더 나은 버전!
나는 group에 넣어주기 전에 해당 group에 사람이 필요한지 안필요한지를 확인해서 넣어줬다.
근데 이렇게 코드를 작성하니까 맨 마지막 group에 대해서 문제의 조건을 충족했는지(공포도이상 사람을 채웠는지) 다시 체크를 해줘야하는 번거로움이 있었다.

그래서 더 좋은 코드가 있지 않을까 생각이 들었고 책의 코드를 보니 역시 더 간결했다ㅎㅅㅎ..
책의 코드는
1. 일단 그룹에 넣고 본다.
2. 그룹에 넣고 나서 공포도이상 사람을 채웠는지 확인한다.
3. 채웠다면 그룹으로 인정하여 답을 증가시킨다.

굳이 나처럼 배열로 만들어서 일일이 length를 확인하고 이럴 필요도 없고,
현재 기준이 되는 그룹의 명수를 담는 count와 그룹의 총 개수를 담는 answer 변수만 있으면 됐다.
왜냐하면 인원수로 체크하기 때문에 1씩 더해가면서 체크하면 되는 것이다. 또한 오름차순으로 이미 정렬했기에 현재 공포도로 count로 비교하면 간단했다!

같은 해결방법을 생각해내도 코드로 구현해내는 방식은 역시 천차만별인 것 같다,,,,,,
*/
const path = require("path");

let [N, fear] = require("fs")
  .readFileSync(path.resolve(__dirname, "./input.txt"))
  .toString()
  .trim()
  .split("\n");

N = +N;
fear = fear.split(" ").map(Number);

fear.sort();

let count = 0; // 현재 기준이 되는 그룹에 포함된 모험가의 수
let answer = 0; // 조건을 충족한 그룹의 개수

fear.forEach((now) => {
  count++; // 1. 일단 현재 그룹에 모험가를 포함시킨다.

  // 2. 그룹의 결성 조건을 만족했는지 확인한다.
  if (count >= now) {
    answer++; // 그룹이 결성됐기 때문에 답을 증가시킨다.
    count = 0; // 그룹의 결성이 끝났기 때문에 count 초기화
  }
});

console.log(answer);
